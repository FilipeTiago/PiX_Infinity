#!/usr/bin/env python3
import sys, os, json, time, socket, subprocess, xml.etree.ElementTree as ET

if len(sys.argv) != 5:
    print("usage: pix_mpv_music_watch <socket> <wall_path> <romroot> <gamelist.xml>", file=sys.stderr)
    sys.exit(2)

SOCK_PATH, WALL, ROMROOT, GMXML = sys.argv[1:]

def connect(path, tries=120, delay=0.1):
    for _ in range(tries):
        try:
            s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            s.connect(path); s.settimeout(0.25); return s
        except Exception:
            time.sleep(delay)
    return None

def send_cmd(sock, cmd):
    try: sock.sendall((json.dumps({"command": cmd})+"\n").encode("utf-8"))
    except Exception: pass

def recv_lines(sock):
    buf = b""
    while True:
        try:
            chunk = sock.recv(4096)
            if not chunk: break
            buf += chunk
            *lines, buf = buf.split(b"\n")
            for ln in lines:
                ln = ln.strip()
                if ln:
                    yield ln
        except socket.timeout:
            # yield nothing, but keep loop alive
            yield from ()
        except Exception:
            break

def get_prop(sock, prop):
    # used only for initial seeding
    send_cmd(sock, ["get_property", prop])
    t0 = time.time()
    while time.time()-t0 < 0.4:
        for ln in recv_lines(sock):
            try:
                obj = json.loads(ln.decode("utf-8"))
                if obj.get("error") == "success":
                    return obj.get("data")
            except Exception: pass
    return None

def parse_gamelist_for_image(abs_path: str):
    try:
        root = ET.parse(GMXML).getroot()
    except Exception:
        return None
    rel = os.path.relpath(abs_path, ROMROOT)
    for game in root.findall(".//game"):
        p = (game.findtext("path") or "").lstrip("./")
        if p == rel:
            img = game.findtext("image")
            if img:
                if img.startswith("/") or img.startswith("~"):
                    return os.path.expanduser(img)
                return os.path.join(ROMROOT, img)
    return None

def find_cover(abs_path: str):
    d = os.path.dirname(abs_path or "")
    base = os.path.splitext(os.path.basename(abs_path or ""))[0]
    # 1) gamelist
    img = parse_gamelist_for_image(abs_path) if abs_path else None
    if img and os.path.isfile(img): return img
    # 2) common in folder
    for c in (f"{base}.jpg", f"{base}.png", "folder.jpg", "folder.png",
              "cover.jpg", "cover.png", "album.jpg", "album.png",
              "front.jpg", "front.png"):
        p = os.path.join(d, c)
        if os.path.isfile(p): return p
    # 3) downloaded_images common
    if abs_path:
        rel = os.path.relpath(abs_path, ROMROOT)
        di = os.path.expanduser("~/.emulationstation/downloaded_images/music")
        for p in (os.path.join(di, os.path.dirname(rel), f"{base}.jpg"),
                  os.path.join(di, f"{base}.jpg"),
                  os.path.join(di, os.path.dirname(rel)+".jpg")):
            if os.path.isfile(p): return p
        # 4) covers/<folder>/cover.jpg
        fld = os.path.basename(d)
        for p in (os.path.join(di, "covers", fld, "cover.jpg"),
                  os.path.join(di, "covers", fld, "cover.png")):
            if os.path.isfile(p): return p
    return None

def convert_wall(title: str, cover: str, out: str):
    title = title or "Playing"
    tmp = out + ".tmp"
    try:
        # base canvas as PNG (avoid XC: issues)
        subprocess.run(["convert", "-size", "1280x720", "canvas:#101014", f"PNG:{tmp}"], check=True)
        if cover and os.path.isfile(cover):
            subprocess.run([
                "convert", f"PNG:{tmp}",
                "(", cover, "-resize", "540x540>", "-background", "none", "-gravity", "center", "-extent", "540x540", ")",
                "-gravity", "West", "-geometry", "+80+0", "-composite",
                "-gravity", "Northwest", "-fill", "white", "-pointsize", "48", "-annotate", "+660+180", title,
                f"PNG:{tmp}"
            ], check=True)
        else:
            subprocess.run([
                "convert", f"PNG:{tmp}",
                "-gravity", "center", "-fill", "#888", "-pointsize", "120", "-annotate", "+0-80", "â™ª",
                "-gravity", "south", "-fill", "white", "-pointsize", "42", "-annotate", "+0+80", title,
                f"PNG:{tmp}"
            ], check=True)
        os.replace(tmp, out)
    except Exception:
        try: os.remove(tmp)
        except Exception: pass

sock = connect(SOCK_PATH)
if not sock:
    sys.exit(0)

# Observe once; mpv will push changes automatically
for i, prop in enumerate(["path", "filename/no-ext", "media-title", "playlist-pos"]):
    send_cmd(sock, ["observe_property", i+1, prop])

# Seed initial state
p = get_prop(sock, "path")
title = (get_prop(sock, "filename/no-ext")
         or get_prop(sock, "media-title")
         or (os.path.splitext(os.path.basename(p or ""))[0] if p else "Playing"))

convert_wall(title, find_cover(p), WALL)

# React only to property-change / start-file / file-loaded (no extra get_property here)
try:
    for ln in recv_lines(sock):
        try:
            obj = json.loads(ln.decode("utf-8"))
        except Exception:
            continue

        ev = obj.get("event")
        changed = False

        if ev == "property-change":
            name = obj.get("name")
            data = obj.get("data")
            if name == "path" and data and data != p:
                p = data; changed = True
            elif name == "filename/no-ext":
                if data and data != title:
                    title = data; changed = True
            elif name == "media-title":
                # only use media-title if we don't have filename/no-ext yet
                if data and not title:
                    title = data; changed = True

        elif ev in ("start-file", "file-loaded"):
            # next item loaded; redraw using current observed state
            changed = True

        if changed and p:
            convert_wall(title or os.path.splitext(os.path.basename(p))[0], find_cover(p), WALL)
except KeyboardInterrupt:
    pass
