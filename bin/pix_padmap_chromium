#!/usr/bin/env python3
import time
from evdev import InputDevice, ecodes, list_devices, UInput

def score_device(d):
    try: caps = d.capabilities(absinfo=False)
    except: return -1
    keys = set(caps.get(ecodes.EV_KEY, []))
    abses = set(caps.get(ecodes.EV_ABS, []))
    score = 0
    for k in (ecodes.BTN_SOUTH, ecodes.BTN_EAST, ecodes.BTN_NORTH, ecodes.BTN_WEST,
              ecodes.BTN_START, ecodes.BTN_SELECT, ecodes.BTN_TL, ecodes.BTN_TR):
        if k in keys: score += 10
    for a in (ecodes.ABS_X, ecodes.ABS_Y, ecodes.ABS_RX, ecodes.ABS_RY, ecodes.ABS_HAT0X, ecodes.ABS_HAT0Y):
        if a in abses: score += 10
    if 'pad' in (d.name or '').lower(): score += 20
    return score

def pick_device():
    devs = [InputDevice(p) for p in list_devices()]
    devs = [d for d in devs if d.fn and 'event' in d.fn]
    if not devs: raise RuntimeError("no input devices")
    return max(devs, key=score_device)

ui = UInput({
    ecodes.EV_REL: [ecodes.REL_X, ecodes.REL_Y, ecodes.REL_WHEEL],
    ecodes.EV_KEY: [ecodes.BTN_LEFT, ecodes.BTN_RIGHT,
                    ecodes.KEY_UP, ecodes.KEY_DOWN,
                    ecodes.KEY_LEFTALT, ecodes.KEY_F4]
}, name="pix-padmap-chromium", version=1)

dev = pick_device()
try:
    dev.grab()
    grabbed = True
except Exception:
    grabbed = False
print(f"[pad] using {dev.fn} ({dev.name}) grabbed={grabbed}", flush=True)

ax = {ecodes.ABS_X:0, ecodes.ABS_Y:0, ecodes.ABS_RX:0, ecodes.ABS_RY:0, ecodes.ABS_HAT0Y:0}
last_hat_y = 0

DEAD = 7000
M_SENS = 0.014
W_SENS = 0.0010
TICK = 0.01

BTN_A = getattr(ecodes, 'BTN_SOUTH', 304)
BTN_B = getattr(ecodes, 'BTN_EAST', 305)

def nz(v): return 0 if abs(v) < DEAD else v
def click(code):
    ui.write(ecodes.EV_KEY, code, 1); ui.syn()
    ui.write(ecodes.EV_KEY, code, 0); ui.syn()
def alt_f4():
    ui.write(ecodes.EV_KEY, ecodes.KEY_LEFTALT, 1); ui.syn()
    click(ecodes.KEY_F4)
    ui.write(ecodes.EV_KEY, ecodes.KEY_LEFTALT, 0); ui.syn()

dev.set_nonblocking(True)
t0 = time.time()
try:
    while True:
        try:
            for e in dev.read():
                if e.type == ecodes.EV_ABS:
                    ax[e.code] = e.value
                elif e.type == ecodes.EV_KEY and e.value == 1:
                    if e.code == BTN_A: alt_f4()
                    elif e.code == BTN_B: click(ecodes.BTN_RIGHT)
        except BlockingIOError:
            pass

        now = time.time()
        if now - t0 >= TICK:
            t0 = now
            mx = int(nz(ax.get(ecodes.ABS_X,0)) * M_SENS)
            my = int(nz(ax.get(ecodes.ABS_Y,0)) * M_SENS)
            if mx or my:
                ui.write(ecodes.EV_REL, ecodes.REL_X, mx)
                ui.write(ecodes.EV_REL, ecodes.REL_Y, my)
                ui.syn()

            ry = nz(ax.get(ecodes.ABS_RY,0))
            wh = int(ry * W_SENS)
            if wh:
                ui.write(ecodes.EV_REL, ecodes.REL_WHEEL, -wh)
                ui.syn()

            haty = ax.get(ecodes.ABS_HAT0Y, 0)
            if haty != last_hat_y:
                if haty == -1: click(ecodes.KEY_UP)
                elif haty == 1: click(ecodes.KEY_DOWN)
                last_hat_y = haty

        time.sleep(0.001)
except KeyboardInterrupt:
    pass
finally:
    try: dev.ungrab()
    except: pass
    ui.close()
