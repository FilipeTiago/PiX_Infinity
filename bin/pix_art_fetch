#!/usr/bin/env bash
set -Eeuo pipefail

# Generic artwork fetcher with caching and fallbacks.
# Usage examples:
#   pix_art_fetch services netflix
#   pix_art_fetch youtube-channel "https://www.youtube.com/@NoCopyrightSounds"
#   pix_art_fetch youtube-playlist "https://www.youtube.com/playlist?list=PLRBp0Fe2GpglETVfP9lRB8P5VxH2KzooR"
#   pix_art_fetch video-file "/home/infinity/RetroPie/roms/videos/Japan/clip.mp4"
#   pix_art_fetch video-folder "/home/infinity/RetroPie/roms/videos/Japan"
#   pix_art_fetch music-file "/home/infinity/RetroPie/roms/music/Album/track01.mp3"
#   pix_art_fetch music-folder "/home/infinity/RetroPie/roms/music/Album"
#   pix_art_fetch iptv "Channel Name|http://example.com/stream.m3u8|tvg-logo=https://â€¦/logo.png"
#   pix_art_fetch radio "Station Name|http://stream.example.com:8000/stream"
#   pix_art_fetch moonlight "Steam Big Picture"
#
# Prints the final PNG path on success; returns 0 even with placeholder,
# never blocks (timeouts and safe placeholders).

ART_ROOT="${PIX_ART_ROOT:-${XDG_DATA_HOME:-$HOME/.local/share}/pix/art}"
TTL_DAYS="${PIX_ART_TTL_DAYS:-180}"
TIMEOUT="${PIX_ART_TIMEOUT_S:-8}"

mkdir -p "$ART_ROOT"

log(){ echo "[pix_art_fetch] $*"; }

hash_key(){ printf '%s' "$1" | sha1sum | awk '{print $1}'; }

safe_png(){
  local dir="$1"; shift
  mkdir -p "$dir"
  local f="$dir/$(hash_key "$*").png"
  printf '%s' "$f"
}

placeholder(){
  local out="$1"; shift
  local label="${1:-NO ART}"
  local up; up="$(printf '%s' "$label" | tr '[:lower:]' '[:upper:]')"
  convert -size 800x800 canvas:none \
    -gravity center \
    -font /usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf \
    -pointsize 120 -fill white \
    -annotate 0 "$up" \
    PNG32:"$out"
}

tile800(){
  # Center-fit an image into 800x800 transparent tile.
  # Usage: tile800 src.png out.png
  local src="$1" out="$2"
  convert "$src" -alpha on -background none -resize 700x700 \
    -gravity center -extent 800x800 PNG32:"$out"
}

curl_dl(){
  # curl with sane defaults + timeout to file
  local url="$1" out="$2"
  curl -fsSLA "pix-art-fetch/1.0" --max-time "$TIMEOUT" "$url" -o "$out"
}

has_fresh(){
  local f="$1"
  [[ -s "$f" ]] && find "$f" -mtime -"${TTL_DAYS}" -print -quit >/dev/null 2>&1
}

# ---------- providers ----------

# services <name>
services_fetch(){
  local name="$1"
  local out_dir="$ART_ROOT/services"
  local out_png="$out_dir/${name}.png"
  mkdir -p "$out_dir"

  if has_fresh "$out_png"; then
    echo "$out_png"; return 0
  fi

  # map to canonical domain
  local domain
  case "$name" in
    netflix) domain="netflix.com" ;;
    disneyplus|disney+) domain="disneyplus.com" ;;
    hbo|max|hbomax) domain="max.com" ;;
    youtube) domain="youtube.com" ;;
    twitch) domain="twitch.tv" ;;
    crunchyroll) domain="crunchyroll.com" ;;
    *) domain="${name}.com" ;;
  esac

  local tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' RETURN

  # Try DuckDuckGo icon (ICO)
  if curl_dl "https://icons.duckduckgo.com/ip3/${domain}.ico" "$tmp/fav.ico" \
     && identify -quiet "$tmp/fav.ico" >/dev/null 2>&1; then
    convert "$tmp/fav.ico[0]" -alpha on -background none -resize 600x600 \
      -gravity center -extent 800x800 PNG32:"$out_png"
    echo "$out_png"; return 0
  fi

  # Try Clearbit PNG
  if curl_dl "https://logo.clearbit.com/${domain}" "$tmp/logo.png" \
     && identify -quiet "$tmp/logo.png" >/dev/null 2>&1; then
    tile800 "$tmp/logo.png" "$out_png"
    echo "$out_png"; return 0
  fi

  placeholder "$out_png" "$name"
  echo "$out_png"
}

# youtube-channel <url-or-handle>
youtube_channel_fetch(){
  local key="$1"
  local out_dir="$ART_ROOT/youtube"
  mkdir -p "$out_dir"
  local out_png; out_png="$(safe_png "$out_dir" "yt-chan-$key")"
  if has_fresh "$out_png"; then echo "$out_png"; return 0; fi

  local tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' RETURN
  if yt-dlp -J --flat-playlist --ignore-errors --no-warnings "$key" >"$tmp/meta.json" 2>/dev/null; then
    # find best thumbnail URL (simple grep for url fields)
    local url
    url="$(grep -oE '"thumbnail":\s*"[^"]+"' "$tmp/meta.json" | head -1 | sed -E 's/.*"thumbnail":\s*"([^"]+)".*/\1/')"
    [[ -z "${url:-}" ]] && url="$(grep -oE '"thumbnails":\s*\[[^]]+\]' "$tmp/meta.json" | tr '"' '\n' | grep -E '^https?://' | head -1 || true)"
    if [[ -n "${url:-}" ]] && curl_dl "$url" "$tmp/pic"; then
      tile800 "$tmp/pic" "$out_png"; echo "$out_png"; return 0
    fi
  fi
  placeholder "$out_png" "youtube"; echo "$out_png"
}

# youtube-playlist <url>
youtube_playlist_fetch(){
  local key="$1"
  local out_dir="$ART_ROOT/youtube"
  mkdir -p "$out_dir"
  local out_png; out_png="$(safe_png "$out_dir" "yt-pl-$key")"
  if has_fresh "$out_png"; then echo "$out_png"; return 0; fi

  local tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' RETURN
  if yt-dlp -J --flat-playlist --ignore-errors --no-warnings "$key" >"$tmp/meta.json" 2>/dev/null; then
    local url
    url="$(grep -oE '"thumbnail":\s*"[^"]+"' "$tmp/meta.json" | head -1 | sed -E 's/.*"thumbnail":\s*"([^"]+)".*/\1/')"
    [[ -n "${url:-}" ]] && curl_dl "$url" "$tmp/pic" && { tile800 "$tmp/pic" "$out_png"; echo "$out_png"; return 0; }
  fi
  placeholder "$out_png" "playlist"; echo "$out_png"
}

# video-file <path>
video_file_fetch(){
  local file="$1"
  local out_dir="$ART_ROOT/videos"
  mkdir -p "$out_dir"
  local out_png; out_png="$(safe_png "$out_dir" "vf-$file")"
  if has_fresh "$out_png"; then echo "$out_png"; return 0; fi

  local tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' RETURN
  # 30% timestamp (avoid black start frames)
  local dur ts
  dur="$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$file" || echo "60")"
  ts="$(awk -v d="$dur" 'BEGIN{printf "%.2f", (d>0? d*0.30:20)}')"
  if ffmpeg -v error -ss "$ts" -i "$file" -frames:v 1 -y "$tmp/frame.png" 2>/dev/null \
     && [[ -s "$tmp/frame.png" ]]; then
    tile800 "$tmp/frame.png" "$out_png"; echo "$out_png"; return 0
  fi
  placeholder "$out_png" "$(basename "$file")"; echo "$out_png"
}

# video-folder <path>
video_folder_fetch(){
  local dir="$1"
  local out_dir="$ART_ROOT/videos"
  mkdir -p "$out_dir"
  local out_png; out_png="$(safe_png "$out_dir" "vd-$dir")"
  if has_fresh "$out_png"; then echo "$out_png"; return 0; fi

  # posters in dir?
  local poster
  for poster in "$dir"/{poster,folder,cover}.{png,jpg,jpeg,webp}; do
    [[ -f "$poster" ]] && { tile800 "$poster" "$out_png"; echo "$out_png"; return 0; }
  done
  # else first video
  local vf
  vf="$(find "$dir" -maxdepth 1 -type f \( -iname '*.mp4' -o -iname '*.mkv' -o -iname '*.avi' -o -iname '*.mov' \) | head -1 || true)"
  [[ -n "$vf" ]] && { video_file_fetch "$vf" | xargs -I{} cp -f "{}" "$out_png"; echo "$out_png"; return 0; }
  placeholder "$out_png" "$(basename "$dir")"; echo "$out_png"
}

# music-file <path>
music_file_fetch(){
  local file="$1"
  local out_dir="$ART_ROOT/music"
  mkdir -p "$out_dir"
  local out_png; out_png="$(safe_png "$out_dir" "mf-$file")"
  if has_fresh "$out_png"; then echo "$out_png"; return 0; fi

  local tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' RETURN
  # Try embedded cover
  if ffmpeg -v error -dump_attachment:0 "$tmp/cover" -i "$file" -f null - 2>/dev/null; then
    if [[ -s "$tmp/cover" ]]; then
      # sometimes no extension; identify will read it
      tile800 "$tmp/cover" "$out_png"; echo "$out_png"; return 0
    fi
  fi
  # Try sibling cover files
  local base_dir; base_dir="$(dirname "$file")"
  local c
  for c in "$base_dir"/{cover,folder,front,album}.{png,jpg,jpeg,webp}; do
    [[ -f "$c" ]] && { tile800 "$c" "$out_png"; echo "$out_png"; return 0; }
  done
  placeholder "$out_png" "$(basename "$file")"; echo "$out_png"
}

# music-folder <path>
music_folder_fetch(){
  local dir="$1"
  local out_dir="$ART_ROOT/music"
  mkdir -p "$out_dir"
  local out_png; out_png="$(safe_png "$out_dir" "md-$dir")"
  if has_fresh "$out_png"; then echo "$out_png"; return 0; fi

  local c
  for c in "$dir"/{cover,folder,front,album}.{png,jpg,jpeg,webp}; do
    [[ -f "$c" ]] && { tile800 "$c" "$out_png"; echo "$out_png"; return 0; }
  done
  # else first audio
  local af
  af="$(find "$dir" -maxdepth 1 -type f \( -iname '*.mp3' -o -iname '*.flac' -o -iname '*.m4a' -o -iname '*.ogg' \) | head -1 || true)"
  [[ -n "$af" ]] && { music_file_fetch "$af" | xargs -I{} cp -f "{}" "$out_png"; echo "$out_png"; return 0; }
  placeholder "$out_png" "$(basename "$dir")"; echo "$out_png"
}

# iptv "Name|stream_url|tvg-logo=<url>"  (tvg-logo optional)
iptv_fetch(){
  local line="$1"
  local name url logo
  name="$(printf '%s' "$line" | awk -F'|' '{print $1}')"
  url="$( printf '%s' "$line" | awk -F'|' '{print $2}')"
  logo="$(printf '%s' "$line" | awk -F'|' '{print $3}' | sed -n 's/^tvg-logo=//p')"

  local out_dir="$ART_ROOT/iptv"
  mkdir -p "$out_dir"
  local out_png; out_png="$(safe_png "$out_dir" "iptv-$name-$url")"
  if has_fresh "$out_png"; then echo "$out_png"; return 0; fi

  local tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' RETURN

  # 1) explicit tvg-logo
  if [[ -n "${logo:-}" ]] && curl_dl "$logo" "$tmp/logo"; then
    tile800 "$tmp/logo" "$out_png"; echo "$out_png"; return 0
  fi
  # 2) favicon of stream domain
  local domain; domain="$(printf '%s' "$url" | sed -E 's#^[a-z]+://##; s#/.*$##; s/:.*$//')"
  if [[ -n "$domain" ]] \
     && curl_dl "https://icons.duckduckgo.com/ip3/${domain}.ico" "$tmp/fav.ico" \
     && identify -quiet "$tmp/fav.ico" >/dev/null 2>&1; then
    convert "$tmp/fav.ico[0]" -alpha on -background none -resize 600x600 \
      -gravity center -extent 800x800 PNG32:"$out_png"
    echo "$out_png"; return 0
  fi
  placeholder "$out_png" "$name"; echo "$out_png"
}

# radio "Name|stream_url"
radio_fetch(){
  local line="$1"
  local name url
  name="$(printf '%s' "$line" | awk -F'|' '{print $1}')"
  url="$( printf '%s' "$line" | awk -F'|' '{print $2}')"

  local out_dir="$ART_ROOT/radio"
  mkdir -p "$out_dir"
  local out_png; out_png="$(safe_png "$out_dir" "radio-$name-$url")"
  if has_fresh "$out_png"; then echo "$out_png"; return 0; fi

  local tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' RETURN

  # Try Radio-Browser favicon (no API key)
  # Simple grep parse to avoid jq dependency
  local q; q="$(python3 -c 'import sys,urllib.parse as u; print(u.quote(sys.argv[1]))' "$name" 2>/dev/null || true)"
  if [[ -n "$q" ]]; then
    curl -fsSLA "pix-art-fetch/1.0" --max-time "$TIMEOUT" \
      "https://de1.api.radio-browser.info/json/stations/byname/${q}" > "$tmp/rb.json" || true
    local fav
    fav="$(tr -d '\n' < "$tmp/rb.json" | sed -E 's/\\\//\//g' | grep -oE '"favicon":"[^"]+"' | head -1 | sed -E 's/"favicon":"([^"]+)".*/\1/')"
    if [[ -n "${fav:-}" ]] && curl_dl "$fav" "$tmp/logo"; then
      tile800 "$tmp/logo" "$out_png"; echo "$out_png"; return 0
    fi
  fi

  # Fallback to stream domain favicon
  local domain; domain="$(printf '%s' "$url" | sed -E 's#^[a-z]+://##; s#/.*$##; s/:.*$//')"
  if [[ -n "$domain" ]] \
     && curl_dl "https://icons.duckduckgo.com/ip3/${domain}.ico" "$tmp/fav.ico" \
     && identify -quiet "$tmp/fav.ico" >/dev/null 2>&1; then
    convert "$tmp/fav.ico[0]" -alpha on -background none -resize 600x600 \
      -gravity center -extent 800x800 PNG32:"$out_png"
    echo "$out_png"; return 0
  fi

  placeholder "$out_png" "$name"; echo "$out_png"
}

# moonlight <app-name>
moonlight_fetch(){
  local app="$1"
  local out_dir="$ART_ROOT/moonlight"
  mkdir -p "$out_dir"
  local out_png; out_png="$(safe_png "$out_dir" "moon-$app")"
  if has_fresh "$out_png"; then echo "$out_png"; return 0; fi

  local tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' RETURN

  # Optional: SteamGridDB if key provided
  if [[ -n "${PIX_SGDB_KEY:-}" ]]; then
    local q; q="$(python3 - <<PY
import json,os,sys,urllib.parse,urllib.request
key=os.getenv("PIX_SGDB_KEY")
app=" ".join(sys.argv[1:])
url="https://www.steamgriddb.com/api/v2/search/autocomplete/"+urllib.parse.quote(app)
req=urllib.request.Request(url,headers={"Authorization":"Bearer "+key})
try:
  with urllib.request.urlopen(req,timeout=8) as r: print(r.read().decode())
except: pass
PY
"$app" 2>/dev/null || true)"
    local img
    img="$(printf '%s' "$q" | tr -d '\n' | sed -E 's/\\\//\//g' | grep -oE '"thumb":"[^"]+"' | head -1 | sed -E 's/"thumb":"([^"]+)".*/\1/')"
    if [[ -n "${img:-}" ]] && curl_dl "$img" "$tmp/pic"; then
      tile800 "$tmp/pic" "$out_png"; echo "$out_png"; return 0
    fi
  fi

  # Fallback to a generic Steam tile to avoid blanks
  services_fetch steam >/dev/null 2>&1 || true
  local steam_png="$ART_ROOT/services/steam.png"
  if [[ -s "$steam_png" ]]; then
    tile800 "$steam_png" "$out_png"; echo "$out_png"; return 0
  fi
  placeholder "$out_png" "$app"; echo "$out_png"
}

# ---------- dispatch ----------

[[ $# -ge 2 ]] || { echo "usage: $0 <provider> <key>"; exit 2; }

provider="$1"; shift
case "$provider" in
  services)            services_fetch "$1" ;;
  youtube-channel)     youtube_channel_fetch "$1" ;;
  youtube-playlist)    youtube_playlist_fetch "$1" ;;
  video-file)          video_file_fetch "$1" ;;
  video-folder)        video_folder_fetch "$1" ;;
  music-file)          music_file_fetch "$1" ;;
  music-folder)        music_folder_fetch "$1" ;;
  iptv)                iptv_fetch "$1" ;;
  radio)               radio_fetch "$1" ;;
  moonlight)           moonlight_fetch "$1" ;;
  *) echo "unknown provider: $provider" >&2; exit 3 ;;
esac

